import type { PipelineStage } from 'mongoose';
import { last, prop, range } from 'rambda';
import { byNum, desc } from 'sort-lib';
import { z } from 'zod';
import { inDateRange } from './helpers.js';
import { BuildDefinitionModel } from './mongoose-models/BuildDefinitionModel.js';
import { RepositoryModel } from './mongoose-models/RepositoryModel.js';
import type { BranchCoverage } from './tests-coverages.js';
import {
  getTestsForBuildIds,
  getCoverageForBuildIDs,
  getMainBranchBuildIds,
  queryForFinishTimeInRange,
  getCoveragesForRepo,
  getOneOldCoverageForBuildDefID,
  getOneOldTestForBuildDefID,
  getTestsForRepo,
} from './tests-coverages.js';
import type { QueryContext } from './utils.js';
import { queryContextInputParser, fromContext } from './utils.js';
import { createIntervals, getLatest } from '../utils.js';

export const TestRunsForRepositoryInputParser = z.object({
  queryContext: queryContextInputParser,
  repositoryId: z.string(),
});

export type BuildDef = { id: number; name: string; url: string };
export type TestsForWeek = {
  weekIndex: number;
} & (
  | { hasTests: false }
  | {
      hasTests: true;
      buildId: number;
      totalTests: number;
      startedDate: Date;
      completedDate: Date;
      passedTests: number;
    }
);
export type TestsForDef = {
  definitionId: number;
  buildId: number;
  tests: TestsForWeek[];
  latest?: TestsForWeek;
  repositoryId: string;
};

export type BuildDefWithTests = BuildDef & Partial<TestsForDef>;

export type BuildDefWithTestsAndCoverage = BuildDef &
  Partial<TestsForDef> &
  Partial<BranchCoverage>;

export const makeContinuous = async <T extends { weekIndex: number }>(
  unsortedDataByWeek: T[] | undefined,
  startDate: Date,
  endDate: Date,
  getOneOlderTestRun: () => Promise<T | null>,
  emptyValue: Omit<T, 'weekIndex'>
) => {
  const { numberOfDays, numberOfIntervals } = createIntervals(startDate, endDate);
  const sortedDataByWeek = unsortedDataByWeek
    ? [...unsortedDataByWeek].sort(byNum(prop('weekIndex')))
    : undefined;

  if (!sortedDataByWeek) {
    const olderTest = await getOneOlderTestRun();
    if (!olderTest) return null;

    return range(0, numberOfIntervals)
      .map(weekIndex => {
        return { ...olderTest, weekIndex };
      })
      .slice(numberOfIntervals - Math.floor(numberOfDays / 7));
  }

  return range(0, numberOfIntervals)
    .reduce<Promise<T[]>>(async (acc, weekIndex, index) => {
      const matchingTest = sortedDataByWeek.find(t => t.weekIndex === weekIndex);

      if (matchingTest) return [...(await acc), matchingTest];

      if (index === 0) {
        const olderTest = await getOneOlderTestRun();

        if (!olderTest) {
          return [{ ...emptyValue, weekIndex } as T];
        }

        return [{ ...olderTest, weekIndex }];
      }

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const lastItem = last(await acc)!;
      return [...(await acc), { ...lastItem, weekIndex }];
    }, Promise.resolve([]))
    .then(list => list.slice(numberOfIntervals - Math.floor(numberOfDays / 7)))
    .then(x => x?.sort(byNum(prop('weekIndex'))));
};

export const combineTestsAndCoverageForRepo = async (
  queryContext: QueryContext,
  repositoryId: string
) => {
  const { collectionName, project } = fromContext(queryContext);

  const [definitionList, definitionTestRuns, branchCoverage] = await Promise.all([
    BuildDefinitionModel.find(
      {
        collectionName,
        project,
        repositoryId,
      },
      {
        _id: 0,
        id: 1,
        name: 1,
        url: 1,
      }
    ).lean(),
    getTestsForRepo(queryContext, repositoryId),
    getCoveragesForRepo(queryContext, repositoryId),
  ]);

  // Mapping the build definitions/pipelines with no testruns
  const buildDefsWithTests: BuildDefWithTests[] = (definitionList as BuildDef[]).map(
    definition => {
      const tests = definitionTestRuns.find(def => def.definitionId === definition.id);
      return { ...definition, ...tests } || definition;
    }
  );

  return (buildDefsWithTests as BuildDefWithTests[]).map(definition => {
    const coverage = branchCoverage.find(def => def.definitionId === definition.id);
    return (
      coverage ? { ...definition, coverageByWeek: coverage.coverageByWeek } : definition
    ) as BuildDefWithTestsAndCoverage;
  });
};

export const getTestRunsAndCoverageForRepo = async ({
  queryContext,
  repositoryId,
}: z.infer<typeof TestRunsForRepositoryInputParser>) => {
  const { collectionName, project, startDate, endDate } = fromContext(queryContext);

  const testRunsAndCoverageForRepo = await combineTestsAndCoverageForRepo(
    queryContext,
    repositoryId
  );
  const getOneOlderTestRunForDef = (defId: number) => () => {
    return getOneOldTestForBuildDefID(
      collectionName,
      project,
      repositoryId,
      defId,
      startDate
    );
  };

  const getOneOlderCoverageForDef = (defId: number) => () => {
    return getOneOldCoverageForBuildDefID(
      collectionName,
      project,
      repositoryId,
      defId,
      startDate
    );
  };

  const definitionTestsAndCoverage = await Promise.all(
    testRunsAndCoverageForRepo.map(async def => {
      const tests = await makeContinuous(
        def.tests,
        startDate,
        endDate,
        getOneOlderTestRunForDef(def.id),
        { hasTests: false }
      );

      const coverageData = await makeContinuous(
        def.coverageByWeek || undefined,
        startDate,
        endDate,
        getOneOlderCoverageForDef(def.id),
        {
          buildId: 0,
          definitionId: 0,
          hasCoverage: false,
        }
      );

      const latestTest = tests ? getLatest(def.tests || []) : null;
      const latestCoverage = coverageData ? getLatest(def.coverageByWeek || []) : null;

      const url = latestTest?.hasTests
        ? `${def.url.split('_apis')[0]}_build/results?buildId=${
            latestTest.buildId
          }&view=ms.vss-test-web.build-test-results-tab`
        : `${def.url.split('_apis')[0]}_build/definition?definitionId=${def.id}`;

      return {
        ...def,
        url,
        tests,
        coverageByWeek: coverageData,
        latestTest,
        latestCoverage,
      };
    })
  );

  return definitionTestsAndCoverage.sort(
    desc(byNum(x => (x.latestTest?.hasTests ? x.latestTest.totalTests : 0)))
  );
};

export const getDefinitionsWithTestsAndCoverages = async (
  queryContext: QueryContext,
  repoIds?: string[]
) => {
  const { collectionName, project, startDate, endDate } = fromContext(queryContext);

  const getMainBranchBuildIdsStage: PipelineStage[] = [
    {
      $match: {
        collectionName,
        'project.name': project,
        ...(repoIds ? { id: { $in: repoIds } } : {}),
      },
    },
    {
      $project: {
        _id: 0,
        collectionName: '$collectionName',
        project: '$project.name',
        repositoryId: '$id',
        repositoryName: '$name',
        defaultBranch: '$defaultBranch',
      },
    },
    {
      $lookup: {
        from: 'builds',
        let: {
          repositoryId: '$repositoryId',
          defaultBranch: '$defaultBranch',
        },
        pipeline: [
          {
            $match: {
              collectionName,
              project,
              $expr: {
                $and: [
                  { $eq: ['$repository.id', '$$repositoryId'] },
                  { $eq: ['$sourceBranch', '$$defaultBranch'] },
                  {
                    $or: [
                      { $eq: ['$result', 'failed'] },
                      { $eq: ['$result', 'succeeded'] },
                    ],
                  },
                ],
              },
              finishTime: inDateRange(startDate, endDate),
            },
          },
          {
            $sort: {
              finishTime: -1,
            },
          },
          {
            $project: {
              _id: 0,
              buildId: '$id',
              sourceBranch: '$sourceBranch',
              definitionId: '$definition.id',
              definitionName: '$definition.name',
              result: '$result',
              finishTime: '$finishTime',
            },
          },
        ],
        as: 'build',
      },
    },
    { $unwind: { path: '$build' } },
  ];

  const [totalDefs, defsWithTests, defsWithCoverage] = await Promise.all([
    BuildDefinitionModel.find({
      collectionName,
      project,
      repositoryId: { $in: repoIds },
    }).count(),

    RepositoryModel.aggregate<{ count: number }>([
      ...getMainBranchBuildIdsStage,
      {
        $lookup: {
          from: 'testruns',
          let: {
            buildId: '$build.buildId',
          },
          pipeline: [
            {
              $match: {
                collectionName,
                'project.name': project,
                '$expr': { $eq: ['$buildConfiguration.id', '$$buildId'] },
                'release': { $exists: false },
              },
            },
            {
              $project: {
                _id: 1,
              },
            },
          ],
          as: 'tests',
        },
      },
      {
        $project: {
          definitionId: '$build.definitionId',
          hasTests: { $gt: [{ $size: '$tests' }, 0] },
        },
      },
      { $match: { hasTests: true } },
      {
        $group: {
          _id: null,
          defsWithTests: {
            $addToSet: '$definitionId',
          },
        },
      },
      {
        $project: {
          _id: 0,
          count: { $size: '$defsWithTests' },
          defsWithTests: 1,
        },
      },
    ]),

    RepositoryModel.aggregate<{ count: number }>([
      ...getMainBranchBuildIdsStage,
      {
        $lookup: {
          from: 'codecoverages',
          let: {
            buildId: '$build.buildId',
          },
          pipeline: [
            {
              $match: {
                collectionName,
                project,
                '$expr': {
                  $eq: ['$build.id', '$$buildId'],
                },
                'coverageData.coverageStats.label': { $in: ['Branch', 'Branches'] },
              },
            },

            { $project: { _id: 1 } },
          ],
          as: 'coverage',
        },
      },
      {
        $project: {
          definitionId: '$build.definitionId',
          hasCoverage: { $gt: [{ $size: '$coverage' }, 0] },
        },
      },
      { $match: { hasCoverage: true } },
      {
        $group: {
          _id: null,
          defsWithCoverage: {
            $addToSet: '$definitionId',
          },
        },
      },
      {
        $project: {
          _id: 0,
          count: { $size: '$defsWithCoverage' },
        },
      },
    ]),
  ]);

  return {
    totalDefs,
    defsWithTests: defsWithTests[0]?.count || 0,
    defsWithCoverage: defsWithCoverage[0]?.count || 0,
  };
};

export const getTestsByWeek = async (
  queryContext: QueryContext,
  repositoryIds: string[]
) => {
  const { collectionName, project, startDate, endDate } = fromContext(queryContext);
  const testrunsForAllDefs = await RepositoryModel.aggregate<TestsForDef>([
    ...getMainBranchBuildIds(
      collectionName,
      project,
      repositoryIds,
      startDate,
      queryForFinishTimeInRange(startDate, endDate)
    ),
    ...getTestsForBuildIds(collectionName, project),
    {
      $group: {
        _id: '$definitionId',
        repositoryId: { $first: '$repositoryId' },
        definitionId: { $first: '$definitionId' },
        tests: { $push: '$$ROOT' },
      },
    },
  ]);

  // TODO: Fixing n+1 Problem of fetching older testruns
  // def IDs where tests array do not have element with weekIndex 0
  // const defsWithoutTests = testrunsForAllDefs.filter(
  //   def => !def.tests.some(test => test.weekIndex === 0)
  // );

  const getOneOlderTestRunForDef = (defId: number, repositoryId: string) => () => {
    return getOneOldTestForBuildDefID(
      collectionName,
      project,
      repositoryId,
      defId,
      startDate
    );
  };

  const weeklyDefinitionTests = await Promise.all(
    testrunsForAllDefs.map(async def => {
      const tests = await makeContinuous(
        def.tests,
        startDate,
        endDate,
        getOneOlderTestRunForDef(def.definitionId, def.repositoryId),
        { hasTests: false }
      );

      return {
        ...def,
        tests,
        latestTest: tests ? getLatest(def.tests || []) : null,
      };
    })
  );

  const flatWeeklyDefinitionTests = weeklyDefinitionTests.flatMap(data => {
    return data.tests || [];
  });

  const { numberOfDays, numberOfIntervals } = createIntervals(startDate, endDate);

  const testsByWeek = range(0, numberOfIntervals).map(weekIndex => {
    const matchingTests = flatWeeklyDefinitionTests.filter(
      def => def.weekIndex === weekIndex
    );

    const totalTests = matchingTests.reduce((acc, curr) => {
      return acc + (curr.hasTests ? curr.totalTests : 0);
    }, 0);

    const passedTests = matchingTests.reduce((acc, curr) => {
      return acc + (curr.hasTests ? curr.passedTests : 0);
    }, 0);

    return {
      weekIndex,
      passedTests,
      totalTests,
    };
  });

  return testsByWeek.slice(numberOfIntervals - Math.floor(numberOfDays / 7));
};

export const getCoveragesByWeek = async (
  queryContext: QueryContext,
  repositoryIds: string[]
) => {
  const { collectionName, project, startDate, endDate } = fromContext(queryContext);
  const coverageForAllDefs = await RepositoryModel.aggregate<BranchCoverage>([
    ...getMainBranchBuildIds(
      collectionName,
      project,
      repositoryIds,
      startDate,
      queryForFinishTimeInRange(startDate, endDate)
    ),
    ...getCoverageForBuildIDs(collectionName, project),
    {
      $group: {
        _id: '$definitionId',
        definitionId: { $first: '$definitionId' },
        repositoryId: { $first: '$repositoryId' },
        coverage: { $push: '$$ROOT' },
      },
    },
    {
      $project: {
        _id: 0,
        definitionId: 1,
        repositoryId: 1,
        coverageByWeek: '$coverage',
      },
    },
  ]);

  // TODO: Fixing n+1 Problem of fetching older coverage
  // def IDs where coverageByWeek array do not have element with weekIndex 0
  // const defsWithoutCoverage = coverageForAllDefs.filter(
  //   def => !def.coverageByWeek.some(coverage => coverage.weekIndex === 0)
  // );

  const getOneOlderCoverageForDef = (defId: number, repositoryId: string) => () => {
    return getOneOldCoverageForBuildDefID(
      collectionName,
      project,
      repositoryId,
      defId,
      startDate
    );
  };

  const weeklyDefinitionCoverage = await Promise.all(
    coverageForAllDefs.map(async def => {
      const coverageData = await makeContinuous(
        def.coverageByWeek || undefined,
        startDate,
        endDate,
        getOneOlderCoverageForDef(def.definitionId, def.repositoryId),
        {
          buildId: 0,
          definitionId: 0,
          hasCoverage: false,
        }
      );

      return {
        ...def,
        coverageByWeek: coverageData,
        latestCoverage: coverageData ? last(coverageData) : null,
      };
    })
  );

  const flatWeeklyDefinitionCoverage = weeklyDefinitionCoverage.flatMap(data => {
    return data.coverageByWeek || [];
  });

  const { numberOfDays, numberOfIntervals } = createIntervals(startDate, endDate);
  const coverageByWeek = range(0, numberOfIntervals).map(weekIndex => {
    const matchingCoverage = flatWeeklyDefinitionCoverage.filter(
      def => def.weekIndex === weekIndex
    );

    const coveredBranches = matchingCoverage.reduce((acc, curr) => {
      return acc + (curr.coverage ? curr.coverage.coveredBranches : 0);
    }, 0);

    const totalBranches = matchingCoverage.reduce((acc, curr) => {
      return acc + (curr.coverage ? curr.coverage.totalBranches : 0);
    }, 0);

    return {
      weekIndex,
      coveredBranches,
      totalBranches,
    };
  });

  return coverageByWeek.slice(numberOfIntervals - Math.floor(numberOfDays / 7));
};

export const getTotalTestsForRepositoryIds = async (
  queryContext: QueryContext,
  repositoryIds: string[]
) => {
  const { collectionName, project, startDate, endDate } = fromContext(queryContext);

  const testsFromDefsOfRepoIds = await RepositoryModel.aggregate<TestsForDef>([
    ...getMainBranchBuildIds(
      collectionName,
      project,
      repositoryIds,
      startDate,
      queryForFinishTimeInRange(startDate, endDate)
    ),
    ...getTestsForBuildIds(collectionName, project),
    {
      $group: {
        _id: '$definitionId',
        id: { $first: '$definitionId' },
        repositoryId: { $first: '$repositoryId' },
        tests: { $push: '$$ROOT' },
      },
    },
    {
      $project: {
        _id: 0,
        id: 1,
        repositoryId: 1,
        tests: 1,
      },
    },
  ]);

  const getOneOlderTestRunForDef = (defId: number, repositoryId: string) => () => {
    return getOneOldTestForBuildDefID(
      collectionName,
      project,
      repositoryId,
      defId,
      startDate
    );
  };

  const definitionTests = await Promise.all(
    testsFromDefsOfRepoIds.map(async def => {
      const tests = await makeContinuous(
        def.tests,
        startDate,
        endDate,
        getOneOlderTestRunForDef(def.definitionId, def.repositoryId),
        { hasTests: false }
      );

      const latestTest = tests ? getLatest(def.tests || []) : null;

      return {
        ...def,
        latestTest,
      };
    })
  );

  return definitionTests.reduce<{ repositoryId: string; totalTests: number }[]>(
    (acc, curr) => {
      const matchingRepo = acc.find(repo => repo.repositoryId === curr.repositoryId);

      if (matchingRepo) {
        matchingRepo.totalTests += curr.latestTest?.hasTests
          ? curr.latestTest.totalTests
          : 0;
      } else {
        acc.push({
          repositoryId: curr.repositoryId,
          totalTests: curr.latestTest?.hasTests ? curr.latestTest.totalTests : 0,
        });
      }

      return acc;
    },
    []
  );
};

export const getReposSortedByTests = async (
  queryContext: QueryContext,
  repositoryIds: string[],
  sortOrder: 'asc' | 'desc',
  pageSize: number,
  pageNumber: number
) => {
  const { collectionName, project, startDate, endDate } = fromContext(queryContext);
  const testrunsForAllDefs = await RepositoryModel.aggregate<TestsForDef>([
    ...getMainBranchBuildIds(
      collectionName,
      project,
      repositoryIds,
      startDate,
      queryForFinishTimeInRange(startDate, endDate)
    ),
    ...getTestsForBuildIds(collectionName, project),
    {
      $group: {
        _id: '$definitionId',
        repositoryId: { $first: '$repositoryId' },
        definitionId: { $first: '$definitionId' },
        tests: { $push: '$$ROOT' },
      },
    },
  ]);

  const getOneOlderTestRunForDef = (defId: number, repositoryId: string) => () => {
    return getOneOldTestForBuildDefID(
      collectionName,
      project,
      repositoryId,
      defId,
      startDate
    );
  };

  const latestDefinitionTests = await Promise.all(
    testrunsForAllDefs.map(async def => {
      const tests = await makeContinuous(
        def.tests,
        startDate,
        endDate,
        getOneOlderTestRunForDef(def.definitionId, def.repositoryId),
        { hasTests: false }
      );

      return {
        ...def,
        latestTest: tests ? getLatest(def.tests || []) : null,
      };
    })
  );

  const allRepos = latestDefinitionTests
    .reduce<{ repositoryId: string; totalTests: number }[]>((acc, curr) => {
      const matchingRepo = acc.find(repo => repo.repositoryId === curr.repositoryId);

      if (matchingRepo) {
        matchingRepo.totalTests += curr.latestTest?.hasTests
          ? curr.latestTest.totalTests
          : 0;
      } else {
        acc.push({
          repositoryId: curr.repositoryId,
          totalTests: curr.latestTest?.hasTests ? curr.latestTest.totalTests : 0,
        });
      }

      return acc;
    }, [])
    .sort(desc(byNum(repo => repo.totalTests)));

  const sortedRepos = sortOrder === 'asc' ? allRepos.reverse() : allRepos;

  return sortedRepos.slice(pageNumber * pageSize, (pageNumber + 1) * pageSize);
};
